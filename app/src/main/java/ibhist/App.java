/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ibhist;

import com.ib.client.Contract;
import com.ib.client.EClientSocket;
import com.ib.client.EReader;
import com.ib.client.EReaderSignal;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;

public class App {
    private static final Logger log = LogManager.getLogger("App");
    private static EClientSocket m_client;
    private static EReaderSignal m_signal;
    private static EReader reader;
    private static final Map<Integer, Action> actions = new TreeMap<>();

    private static final AtomicInteger id = new AtomicInteger(100);

    private static final BlockingQueue<Action> queue = new ArrayBlockingQueue<>(16);

    public static void main(String[] args) {
        log.info(System.getProperty("java.version"));
        EWrapperImpl wrapper = new EWrapperImpl(actions);

        m_client = wrapper.getClient();
        m_signal = wrapper.getSignal();
        //! [connect]
        m_client.eConnect("127.0.0.1", 7496, 0);
        //! [connect]
        //! [ereader]
        reader = new EReader(m_client, m_signal);

        reader.start();
        new Thread(App::connectionThread).start();
        sleep(1_000);
        m_client.reqCurrentTime();
        getHistoricalData("ES", "202312", Duration.DAY_1);
//        getHistoricalData("NQ", "202312", Duration.DAY_5);
//        sleep(30_000);
        m_client.eDisconnect();
        sleep(1_000);
    }

    private static void getHistoricalData(String symbol, String contractMonth, Duration duration) {
        try {
            requestContractDetails(symbol, contractMonth);
            var action = takeFromQueue(ContractDetailsAction.class);
            processContractDetails(action);

            requestHistoricalData(action.getContract(),  duration);
            var hdAction = takeFromQueue(HistoricalDataAction.class);
            processHistoricalData(hdAction);
        } catch (InterruptedException e) {
            log.error(e);
        }
    }

    private static <T> T takeFromQueue(Class<T> clz) throws InterruptedException {
        return clz.cast(queue.take());
    }

    static void connectionThread() {
        try {
            log.info("starting waiting for connection");
            while (m_client.isConnected()) {
                m_signal.waitForSignal();
//            log.info("connected");
                reader.processMsgs();
            }
            log.info("ended");
        } catch (Exception e) {
            log.error(e);
        }
    }

    private static void requestContractDetails(String symbol, String contractMonth) {
        log.info("contractOperations");
//        m_client.reqContractDetails(id.getAndIncrement(), simpleFuture("ES", "202312"));
        var action = new ContractDetailsAction(m_client, id, queue, newFutureContract(symbol, contractMonth));
        actions.put(action.getRequestId(), action);
        action.makeRequest();
    }

    private static void requestHistoricalData(Contract contract, Duration duration) {
        log.info("historicalData");
        var action = new HistoricalDataAction(m_client, id, queue, contract, duration);
        actions.put(action.getRequestId(), action);
        action.makeRequest();
//        action.cancel();
    }

    private static void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException ignored) {
        }
    }

    private static void processContractDetails(ContractDetailsAction action) {
        var cd = action.getContractDetails();
        log.info(cd.conid() + " " + cd.contract().description());
    }

    private static void processHistoricalData(HistoricalDataAction action) {
        var bars = action.getBars();
        var contract = action.getContract();
        log.info("processHistoricalData " + bars.size());
        if (!bars.isEmpty()) {
            log.info(contract.localSymbol() + " bars from " + bars.get(0).time() + " to " + bars.get(bars.size() - 1).time());
            var history = action.getPriceHistory();
            var vwap = history.vwap("vwap");
            var index = history.index();
            var entry = index.entries().get(0);
//            var index2 = history.index();
//            action.save(entry.tradeDate());
            TimeSeriesRepository repository = new TimeSeriesRepository("mongodb://localhost:27017");
            repository.append(history);
        }
    }

    public static Contract newFutureContract(String symbol, String contractMonth) {
        //! [futcontract]
        Contract contract = new Contract();
        contract.symbol(symbol);
        contract.lastTradeDateOrContractMonth(contractMonth);
        contract.secType("FUT");
        contract.currency("USD");
        contract.exchange("CME");
        //! [futcontract]
        return contract;
    }
}
